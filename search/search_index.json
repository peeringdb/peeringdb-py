{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PeeringDB Python Client This is an early release of our client package, it's fairly new, but we're releasing early to get feedback as soon as possible. This release represents a redesign and refactor of the Python client. What's included? By installing the package, you get both a client library and a command line utility . What's new? The object-relational mapping backend is now configurable. Therefore, the dependency on django_peeringdb is now a soft dependency. However, it is currently the only available backend, so it will still need to be installed. Submissions and requests for new backend modules are welcome. Migrating from old version Old databases should be compatible with this version of peeringdb as long as the version of the backend used is compatible. This version can be checked with peeringdb.get_backend_info()[1] after initializing the client. How to install For those unfamiliar with python, you'll usually want to install to a separate virtualenv . virtualenv pdbvenv . pdbvenv/bin/activate Install the peeringdb package with pip install peeringdb Install the Django backend with: pip install django_peeringdb Configuration Both command line and library will try to use a common config file, by default located at ~/.peeringdb/config.yaml You can go through a setup wizard to configure and create the config (also downloads any needed requirements) with: peeringdb config set To skip the wizard and write a config file with the defaults: peeringdb config set -n Then edit the file it created (default ~/peeringdb/config.yaml ). Currently, since only Django is supported, any database backend Django supports will work, for example, to sync to MySQL, you could use the following database config: database: engine: mysql host: localhost name: peeringdb user: peeringdb password: supers3cr3t If you provide authentication in your config file, it will include contacts much like version 1 did. Authentication To sync with peeringdb API servers, you need to provide authentication. Basic authentication is supported, but you can also use your API keys. To sync with PeeringDB, you can add the following config: sync: api_key: 'YOUR_API_KEY_HERE' user: 'username' password: 'password' only: [] strip_tz: 1 timeout: 0 url: https://peeringdb.com/api This will also be prompted during the configuration wizard. Please take note that only one authentication method is supported, either basic or API key. Tips MySQL You need to use utf8 and a utf8 collation before doing the initial sync. New database: CREATE DATABASE peeringdb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; or existing database: ALTER DATABASE peeringdb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; pip and setuputils If you are getting the error 'install_requires' must be a string or list of strings containing valid project/version requirement specifiers; Expected ',' or end-of-list in ipaddress =1; python_version '3.3' at ; python_version '3.3' , update pip and setuptools. pip install -U pip pip install -U setuptools Ubuntu / Debian If you have issues building the mysqlclient install the dev libraries: sudo apt install libmysqlclient-dev","title":"Home"},{"location":"#peeringdb-python-client","text":"This is an early release of our client package, it's fairly new, but we're releasing early to get feedback as soon as possible. This release represents a redesign and refactor of the Python client.","title":"PeeringDB Python Client"},{"location":"#whats-included","text":"By installing the package, you get both a client library and a command line utility .","title":"What's included?"},{"location":"#whats-new","text":"The object-relational mapping backend is now configurable. Therefore, the dependency on django_peeringdb is now a soft dependency. However, it is currently the only available backend, so it will still need to be installed. Submissions and requests for new backend modules are welcome.","title":"What's new?"},{"location":"#migrating-from-old-version","text":"Old databases should be compatible with this version of peeringdb as long as the version of the backend used is compatible. This version can be checked with peeringdb.get_backend_info()[1] after initializing the client.","title":"Migrating from old version"},{"location":"#how-to-install","text":"For those unfamiliar with python, you'll usually want to install to a separate virtualenv . virtualenv pdbvenv . pdbvenv/bin/activate Install the peeringdb package with pip install peeringdb Install the Django backend with: pip install django_peeringdb","title":"How to install"},{"location":"#configuration","text":"Both command line and library will try to use a common config file, by default located at ~/.peeringdb/config.yaml You can go through a setup wizard to configure and create the config (also downloads any needed requirements) with: peeringdb config set To skip the wizard and write a config file with the defaults: peeringdb config set -n Then edit the file it created (default ~/peeringdb/config.yaml ). Currently, since only Django is supported, any database backend Django supports will work, for example, to sync to MySQL, you could use the following database config: database: engine: mysql host: localhost name: peeringdb user: peeringdb password: supers3cr3t If you provide authentication in your config file, it will include contacts much like version 1 did.","title":"Configuration"},{"location":"#authentication","text":"To sync with peeringdb API servers, you need to provide authentication. Basic authentication is supported, but you can also use your API keys. To sync with PeeringDB, you can add the following config: sync: api_key: 'YOUR_API_KEY_HERE' user: 'username' password: 'password' only: [] strip_tz: 1 timeout: 0 url: https://peeringdb.com/api This will also be prompted during the configuration wizard. Please take note that only one authentication method is supported, either basic or API key.","title":"Authentication"},{"location":"#tips","text":"","title":"Tips"},{"location":"#mysql","text":"You need to use utf8 and a utf8 collation before doing the initial sync. New database: CREATE DATABASE peeringdb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; or existing database: ALTER DATABASE peeringdb DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;","title":"MySQL"},{"location":"#pip-and-setuputils","text":"If you are getting the error 'install_requires' must be a string or list of strings containing valid project/version requirement specifiers; Expected ',' or end-of-list in ipaddress =1; python_version '3.3' at ; python_version '3.3' , update pip and setuptools. pip install -U pip pip install -U setuptools","title":"pip and setuputils"},{"location":"#ubuntu-debian","text":"If you have issues building the mysqlclient install the dev libraries: sudo apt install libmysqlclient-dev","title":"Ubuntu / Debian"},{"location":"api/","text":"Application Programming Interface Instantiate from peeringdb import Client pdb = Client() Calls Methods on Client correspond directly to PeeringDB REST API calls. get(self, res, id) Gets a single object of specified type and id. all(self, res, **kwargs) Gets all objects of specified type, matching query from kwargs, valid kwargs are available here . query(self, res) Returns a wrapper object that directly performs operations on data of the specified resource type. update(self, res, id, **kwargs) Update an object of specified type from kwargs. Full Example from peeringdb import Client, config, resource pdb = Client() # sync database with remote data # unauthenticated to default URL unless configured pdb.update_all() # get a single record n1 = pdb.get(resource.Network, 1) net = pdb.tags.net # type wrap # both are equal assert net.get(1) == n1 # query by parameter pdb.all(resource.Network).filter(asn=2906) # or net.all().filter(asn=2906)","title":"API"},{"location":"api/#application-programming-interface","text":"","title":"Application Programming Interface"},{"location":"api/#instantiate","text":"from peeringdb import Client pdb = Client()","title":"Instantiate"},{"location":"api/#calls","text":"Methods on Client correspond directly to PeeringDB REST API calls.","title":"Calls"},{"location":"api/#getself-res-id","text":"Gets a single object of specified type and id.","title":"get(self, res, id)"},{"location":"api/#allself-res-kwargs","text":"Gets all objects of specified type, matching query from kwargs, valid kwargs are available here .","title":"all(self, res, **kwargs)"},{"location":"api/#queryself-res","text":"Returns a wrapper object that directly performs operations on data of the specified resource type.","title":"query(self, res)"},{"location":"api/#updateself-res-id-kwargs","text":"Update an object of specified type from kwargs.","title":"update(self, res, id, **kwargs)"},{"location":"api/#full-example","text":"from peeringdb import Client, config, resource pdb = Client() # sync database with remote data # unauthenticated to default URL unless configured pdb.update_all() # get a single record n1 = pdb.get(resource.Network, 1) net = pdb.tags.net # type wrap # both are equal assert net.get(1) == n1 # query by parameter pdb.all(resource.Network).filter(asn=2906) # or net.all().filter(asn=2906)","title":"Full Example"},{"location":"backend/","text":"How to configure The object-relational mapping backend can be configured with the orm.backend config parameter. For example, in YAML: orm: backend: django_peeringdb database: engine: sqlite3 name: peeringdb.sqlite3 The only currently available backend module is for Django, django_peeringdb . Other backends may be supported in the future as needed. To install the Django backend: pip install django_peeringdb Make sure that the backend module is configured properly. Backend interface A custom module can be defined by implementing the following methods and types, as well as pointing peeringdb to a module containing a load_backend(**kwargs) method which returns the implementation module as an object. For example: peeringdb.SUPPORTED_BACKENDS[\"new_backend\"] = \"my_app.peeringdb_adaptor_module\" conf = peeringdb.config.load_config(\"~/new_orm_config/\") client = peeringdb.PeeringDB(conf) In your PeeringDB config file: orm: backend: new_backend database: ... In my_app/peeringdb_adaptor_module.py : import impl_module as impl # or: # class Backend: ... # impl = Backend() def load_backend(**options): impl.configure(options) return impl The requirements on a backend adaptor class are outlined below. Interface Interface(peeringdb.backend.Base) backend adapter interface extend this when making a new backend is_field_related is_field_related(*args, **kwargs) Should return a tuple containing bools on whether a field signifies a relationship and if it's a single relationship or a relationship to multiple objects Arguments: - concrete: concrete class - field_name: query this field for a match Returns: - tuple: (bool related, bool many) get_field_names get_field_names(*args, **kwargs) Should return a list of field names for the concrete class Arguments: - concrete: concrete class Returns: - list: [ str ,...] create_object create_object(*args, **kwargs) should create object from dict and return it Arguments: - concrete: concrete class Keyword Arguments: - object field names - values get_object get_object(*args, **kwargs) should return instance of object with matching id Arguments: - concrete: concrete class - id: object primary key value Returns: - concrete instance convert_field convert_field(*args, **kwargs) Should take a value and a field definition and do a value conversion if needed. should return the new value. Arguments: - concrete: concrete class - field_name - value update update(self, obj, field_name, value) update field on a concrete instance to value this does not have to commit to the database, which will be handled separately via the save method. Arguments: - obj: concrete object instance - field_name - value get_field_concrete get_field_concrete(*args, **kwargs) Return concrete class for relationship by field name Arguments: - concrete: concrete class - field_name Returns: - concrete class get_objects_by get_objects_by(*args, **kwargs) very simple search function that should return collection of objects where field matches value Arguments: - concrete: concrete class - field_name: query this field for a match - value: match this value (simple equal matching) Returns: - collection of concrete instances migrate_database migrate_database(self, verbosity=0) Do database migrations Arguments: - verbosity int : arbitrary verbosity setting, 0 = be silent, 1 = show some info about migrations. get_object_by get_object_by(*args, **kwargs) very simply search function that should return collection of objects where field matches value Arguments: - concrete: concrete class - field_name: query this field for a match - value: match this value (simple equal matching) Returns: - concrete instance detect_uniqueness_error detect_uniqueness_error(self, exc) Should parse error message and collect any that describe violations of a uniqueness constraint. return the curresponding fields, else None Arguments: - exc: exception instance Returns: - list: list of fields - None: if no uniqueness errors set_relation_many_to_many set_relation_many_to_many(self, obj, field_name, objs) Setup a many to many relationship Arguments: - obj: concrete object instance - field_name: name of the field that holds the relationship - objs: collection of concrete objects to setup relationships with get_fields get_fields(*args, **kwargs) Should return a collection of fields, if your backend does not use classes to describe fields, leave this as is Arguments: - concrete: concrete class Returns: - collection of field instances detect_missing_relations detect_missing_relations(self, obj, exc) Should parse error messages and collect the missing relationship errors as a dict of Resource - {id set} and return it Arguments: - obj: concrete object instance - exc: exception instance Returns: - dict: {Resource : [ids]} get_objects get_objects(*args, **kwargs) should return collection of objects Arguments: - concrete: concrete class - ids: if specified should be a list of primary key values and only objects matching those values should be returned Returns: - collection of concrete instances clean clean(self, obj) Should take an object instance and validate / clean it Arguments: - obj: concrete object instance delete_all delete_all(self) Delete all objects, essentially empty the database get_field get_field(*args, **kwargs) Should retrun a field instance, if your backend does not use classes to describe fields, leave this as is Arguments: - concrete: concrete class - field_name Returns: - field instance save save(self, obj) Save the object instance Arguments: - obj: concrete object instance last_change last_change(*args, **kwargs) should return unix epoch timestamp of the updated field of the most recently updated object Arguments: - concrete: concrete class Returns: - int is_database_migrated is_database_migrated(self, **kwargs) Should return whether the database is fully migrated Returns: - bool","title":"How to configure"},{"location":"backend/#how-to-configure","text":"The object-relational mapping backend can be configured with the orm.backend config parameter. For example, in YAML: orm: backend: django_peeringdb database: engine: sqlite3 name: peeringdb.sqlite3 The only currently available backend module is for Django, django_peeringdb . Other backends may be supported in the future as needed. To install the Django backend: pip install django_peeringdb Make sure that the backend module is configured properly.","title":"How to configure"},{"location":"backend/#backend-interface","text":"A custom module can be defined by implementing the following methods and types, as well as pointing peeringdb to a module containing a load_backend(**kwargs) method which returns the implementation module as an object. For example: peeringdb.SUPPORTED_BACKENDS[\"new_backend\"] = \"my_app.peeringdb_adaptor_module\" conf = peeringdb.config.load_config(\"~/new_orm_config/\") client = peeringdb.PeeringDB(conf) In your PeeringDB config file: orm: backend: new_backend database: ... In my_app/peeringdb_adaptor_module.py : import impl_module as impl # or: # class Backend: ... # impl = Backend() def load_backend(**options): impl.configure(options) return impl The requirements on a backend adaptor class are outlined below.","title":"Backend interface"},{"location":"backend/#interface","text":"Interface(peeringdb.backend.Base) backend adapter interface extend this when making a new backend","title":"Interface"},{"location":"backend/#is_field_related","text":"is_field_related(*args, **kwargs) Should return a tuple containing bools on whether a field signifies a relationship and if it's a single relationship or a relationship to multiple objects Arguments: - concrete: concrete class - field_name: query this field for a match Returns: - tuple: (bool related, bool many)","title":"is_field_related"},{"location":"backend/#get_field_names","text":"get_field_names(*args, **kwargs) Should return a list of field names for the concrete class Arguments: - concrete: concrete class Returns: - list: [ str ,...]","title":"get_field_names"},{"location":"backend/#create_object","text":"create_object(*args, **kwargs) should create object from dict and return it Arguments: - concrete: concrete class Keyword Arguments: - object field names - values","title":"create_object"},{"location":"backend/#get_object","text":"get_object(*args, **kwargs) should return instance of object with matching id Arguments: - concrete: concrete class - id: object primary key value Returns: - concrete instance","title":"get_object"},{"location":"backend/#convert_field","text":"convert_field(*args, **kwargs) Should take a value and a field definition and do a value conversion if needed. should return the new value. Arguments: - concrete: concrete class - field_name - value","title":"convert_field"},{"location":"backend/#update","text":"update(self, obj, field_name, value) update field on a concrete instance to value this does not have to commit to the database, which will be handled separately via the save method. Arguments: - obj: concrete object instance - field_name - value","title":"update"},{"location":"backend/#get_field_concrete","text":"get_field_concrete(*args, **kwargs) Return concrete class for relationship by field name Arguments: - concrete: concrete class - field_name Returns: - concrete class","title":"get_field_concrete"},{"location":"backend/#get_objects_by","text":"get_objects_by(*args, **kwargs) very simple search function that should return collection of objects where field matches value Arguments: - concrete: concrete class - field_name: query this field for a match - value: match this value (simple equal matching) Returns: - collection of concrete instances","title":"get_objects_by"},{"location":"backend/#migrate_database","text":"migrate_database(self, verbosity=0) Do database migrations Arguments: - verbosity int : arbitrary verbosity setting, 0 = be silent, 1 = show some info about migrations.","title":"migrate_database"},{"location":"backend/#get_object_by","text":"get_object_by(*args, **kwargs) very simply search function that should return collection of objects where field matches value Arguments: - concrete: concrete class - field_name: query this field for a match - value: match this value (simple equal matching) Returns: - concrete instance","title":"get_object_by"},{"location":"backend/#detect_uniqueness_error","text":"detect_uniqueness_error(self, exc) Should parse error message and collect any that describe violations of a uniqueness constraint. return the curresponding fields, else None Arguments: - exc: exception instance Returns: - list: list of fields - None: if no uniqueness errors","title":"detect_uniqueness_error"},{"location":"backend/#set_relation_many_to_many","text":"set_relation_many_to_many(self, obj, field_name, objs) Setup a many to many relationship Arguments: - obj: concrete object instance - field_name: name of the field that holds the relationship - objs: collection of concrete objects to setup relationships with","title":"set_relation_many_to_many"},{"location":"backend/#get_fields","text":"get_fields(*args, **kwargs) Should return a collection of fields, if your backend does not use classes to describe fields, leave this as is Arguments: - concrete: concrete class Returns: - collection of field instances","title":"get_fields"},{"location":"backend/#detect_missing_relations","text":"detect_missing_relations(self, obj, exc) Should parse error messages and collect the missing relationship errors as a dict of Resource - {id set} and return it Arguments: - obj: concrete object instance - exc: exception instance Returns: - dict: {Resource : [ids]}","title":"detect_missing_relations"},{"location":"backend/#get_objects","text":"get_objects(*args, **kwargs) should return collection of objects Arguments: - concrete: concrete class - ids: if specified should be a list of primary key values and only objects matching those values should be returned Returns: - collection of concrete instances","title":"get_objects"},{"location":"backend/#clean","text":"clean(self, obj) Should take an object instance and validate / clean it Arguments: - obj: concrete object instance","title":"clean"},{"location":"backend/#delete_all","text":"delete_all(self) Delete all objects, essentially empty the database","title":"delete_all"},{"location":"backend/#get_field","text":"get_field(*args, **kwargs) Should retrun a field instance, if your backend does not use classes to describe fields, leave this as is Arguments: - concrete: concrete class - field_name Returns: - field instance","title":"get_field"},{"location":"backend/#save","text":"save(self, obj) Save the object instance Arguments: - obj: concrete object instance","title":"save"},{"location":"backend/#last_change","text":"last_change(*args, **kwargs) should return unix epoch timestamp of the updated field of the most recently updated object Arguments: - concrete: concrete class Returns: - int","title":"last_change"},{"location":"backend/#is_database_migrated","text":"is_database_migrated(self, **kwargs) Should return whether the database is fully migrated Returns: - bool","title":"is_database_migrated"},{"location":"cli/","text":"Command Line Interface $ peeringdb -h usage: peeringdb [-h] [--version] [-C CONFIG_DIR] {sync,get,whois,config} ... positional arguments: {sync,get,whois,config} sync Synchronize local tables to PeeringDB get Get a resource whois Simulate a whois lookup supports as ASN : query by AS ixlans net id : query networks on an IX config Configuration management optional arguments: -h, --help show this help message and exit --version show program's version number and exit -C CONFIG_DIR, --config-dir CONFIG_DIR Directory containing configuration files Commands Configuration config show Outputs current config. config set Prompts user for input to configure local database. With -n, writes a config file with all options and defaults to the config directory (changable with -C). Example: $ peeringdb -C ~/.new-config/ config set -n config list-codecs Lists available config codec formats. get obj id Fetches a specific object and outputs to stdout. You may use the CLI to dump any object in the database with , for example: peeringdb get net1 By default, this produces a shallow output (depth = 0). Set the depth with --depth / -D : peeringdb get net1 -D2 You may also change the output format to anything munge supports, so to get json, it would be: peeringdb -O json get net1 whois obj id Fetches a specific object and outputs to stdout, supports everything that get does, as well as: as ASN : query by AS ixlans net id : query networks on an IX drop-tables Warning This will delete data. Drops all peeringdb tables. sync Synchronizes PeeringDB to a local database. After doing a full sync, it only updates objects that have changed. By default, peeringdb will sync to a file in the config dir called peeringdb.sqlite3 - to change that, see configuration Once the database is configured how you'd like it, you can do an initial sync of the database with peeringdb sync Then add a cron job to keep it in sync, for example, once a day at between midnight and midnight plus 10 minutes, with random sleep delay to prevent thundering herd: crontab -l | { cat; echo \"$(expr $RANDOM % 60) 0 * * * $(which peeringdb) sync /dev/null 2 1\"; } | crontab - Or, if your cron supports random: crontab -l | { cat; echo \"0 0 * * * sleep \\$[RANDOM\\%600] ; $(which peeringdb) sync /dev/null 2 1\"; } | crontab -","title":"CLI"},{"location":"cli/#command-line-interface","text":"$ peeringdb -h usage: peeringdb [-h] [--version] [-C CONFIG_DIR] {sync,get,whois,config} ... positional arguments: {sync,get,whois,config} sync Synchronize local tables to PeeringDB get Get a resource whois Simulate a whois lookup supports as ASN : query by AS ixlans net id : query networks on an IX config Configuration management optional arguments: -h, --help show this help message and exit --version show program's version number and exit -C CONFIG_DIR, --config-dir CONFIG_DIR Directory containing configuration files","title":"Command Line Interface"},{"location":"cli/#commands","text":"","title":"Commands"},{"location":"cli/#configuration","text":"","title":"Configuration"},{"location":"cli/#config-show","text":"Outputs current config.","title":"config show"},{"location":"cli/#config-set","text":"Prompts user for input to configure local database. With -n, writes a config file with all options and defaults to the config directory (changable with -C). Example: $ peeringdb -C ~/.new-config/ config set -n","title":"config set"},{"location":"cli/#config-list-codecs","text":"Lists available config codec formats.","title":"config list-codecs"},{"location":"cli/#get-ltobjgtltidgt","text":"Fetches a specific object and outputs to stdout. You may use the CLI to dump any object in the database with , for example: peeringdb get net1 By default, this produces a shallow output (depth = 0). Set the depth with --depth / -D : peeringdb get net1 -D2 You may also change the output format to anything munge supports, so to get json, it would be: peeringdb -O json get net1","title":"get &lt;obj&gt;&lt;id&gt;"},{"location":"cli/#whois-ltobjgtltidgt","text":"Fetches a specific object and outputs to stdout, supports everything that get does, as well as: as ASN : query by AS ixlans net id : query networks on an IX","title":"whois &lt;obj&gt;&lt;id&gt;"},{"location":"cli/#drop-tables","text":"Warning This will delete data. Drops all peeringdb tables.","title":"drop-tables"},{"location":"cli/#sync","text":"Synchronizes PeeringDB to a local database. After doing a full sync, it only updates objects that have changed. By default, peeringdb will sync to a file in the config dir called peeringdb.sqlite3 - to change that, see configuration Once the database is configured how you'd like it, you can do an initial sync of the database with peeringdb sync Then add a cron job to keep it in sync, for example, once a day at between midnight and midnight plus 10 minutes, with random sleep delay to prevent thundering herd: crontab -l | { cat; echo \"$(expr $RANDOM % 60) 0 * * * $(which peeringdb) sync /dev/null 2 1\"; } | crontab - Or, if your cron supports random: crontab -l | { cat; echo \"0 0 * * * sleep \\$[RANDOM\\%600] ; $(which peeringdb) sync /dev/null 2 1\"; } | crontab -","title":"sync"}]}